<script>
        const CONFIG = {
            walkThreshold: 10, 
            jumpThreshold: 65, 
            gravity: 0.5,
            jumpForce: -13,
            baseSpeed: 4
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level-indicator');
        const statusEl = document.getElementById('status');
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const errorLog = document.getElementById('error-log');
        const volBar = document.getElementById('vol-bar');

        canvas.width = 800;
        canvas.height = 400;
        ctx.imageSmoothingEnabled = false;

        let audioContext, analyser, dataArray;
        let gameRunning = false;
        let distance = 0;
        let speedMultiplier = 1;
        let player = { x: 150, y: 320, width: 30, height: 30, vy: 0, grounded: true };
        let movingMomentum = false; 
        let wasWalking = false;     
        let obstacles = [];
        let clouds = [];

        // --- ROBUST ASSET LOADER ---
        const Assets = {
            images: {},
            sounds: {},
            loaded: 0,
            toLoad: 2, 
            onReady: null,

            loadImages: function() {
                // TREE
                this.images.tree = new Image();
                this.images.tree.onload = () => { console.log("Tree loaded"); this.assetLoaded(); };
                this.images.tree.onerror = () => { 
                    console.error("MISSING: media/pine_tree.png"); 
                    showError("Warning: 'pine_tree.png' not found."); 
                    this.assetLoaded(); // Proceed anyway to avoid freeze
                };
                this.images.tree.src = 'media/pine_tree.png'; 

                // GROUND
                this.images.ground = new Image();
                this.images.ground.onload = () => { console.log("Ground loaded"); this.assetLoaded(); };
                this.images.ground.onerror = () => { 
                    console.error("MISSING: media/mountain_ground.png"); 
                    showError("Warning: 'mountain_ground.png' not found."); 
                    this.assetLoaded(); // Proceed anyway
                };
                this.images.ground.src = 'media/mountain_ground.png'; 
            },

            loadSounds: function() {
                try {
                    this.sounds.jump = new Audio('media/jump.wav');
                    this.sounds.death = new Audio('media/death.wav');
                    this.sounds.music = new Audio('media/music.mp3');
                    this.sounds.music.loop = true;
                    this.sounds.music.volume = 0.3; 
                } catch(e) { console.warn("Sounds failed to init"); }
            },

            assetLoaded: function() {
                this.loaded++;
                // If all critical images (2) are accounted for (success or fail)
                if(this.loaded === this.toLoad && this.onReady) {
                    this.onReady();
                }
            },

            playJump: function() { if(this.sounds.jump) { this.sounds.jump.currentTime = 0; this.sounds.jump.play().catch(e=>{}); } },
            playDeath: function() { if(this.sounds.death) { this.sounds.death.play().catch(e=>{}); } }
        };

        async function startGame() {
            startBtn.disabled = true;
            startBtn.innerText = "Checking Files...";
            errorLog.style.display = 'none';

            Assets.onReady = async () => {
                startBtn.innerText = "Connecting Mic...";
                await initializeAudio();
            };

            Assets.loadImages();
            Assets.loadSounds();
        }

        async function initializeAudio() {
             if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { 
                showError("Browser not supported. Use Chrome/Edge."); return; 
            }
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') await audioContext.resume();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                startScreen.style.display = 'none';
                resetGame();
                gameRunning = true;
                if(Assets.sounds.music) Assets.sounds.music.play().catch(e => console.log("Music autoplay blocked - tap screen"));
                requestAnimationFrame(gameLoop);

            } catch (err) {
                console.error(err);
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showError("Microphone Denied. Refresh and Allow.");
                } else {
                    showError("Error: " + err.message);
                }
                startBtn.disabled = false;
                startBtn.innerText = "Try Again";
            }
        }

        function showError(msg) { errorLog.innerText = msg; errorLog.style.display = 'block'; }

        function getVolumeLevel() {
            if (!analyser) return 0;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            let avg = sum / dataArray.length;
            return Math.min(100, avg * 2.8); 
        }

        function resetGame() {
            player.y = 320; player.vy = 0; player.grounded = true;
            movingMomentum = false; wasWalking = false;
            distance = 0; speedMultiplier = 1;
            scoreEl.innerText = "0m"; levelEl.innerText = "Level 1";
            obstacles = []; clouds = [];
            obstacles.push({ x: 0, y: 350, w: 800, h: 50, type: 'floor' });
            for(let i=0; i<6; i++) clouds.push({ x: Math.random() * canvas.width, y: Math.random() * 150, size: 20 + Math.random() * 30, speed: 0.5 + Math.random() * 1 });
        }

        function calculateDifficulty() {
            let level = 1 + Math.floor(distance / 1000);
            let targetSpeed = 1 + (level * 0.15); 
            speedMultiplier = Math.min(2.0, targetSpeed);
            levelEl.innerText = "Level " + level + (speedMultiplier >= 2.0 ? " (MAX)" : "");
            return level;
        }

        function spawnTerrain() {
            const lastObs = obstacles[obstacles.length - 1];
            if (lastObs && (lastObs.x + lastObs.w) < canvas.width + 100) {
                let level = calculateDifficulty();
                let startX = lastObs.x + lastObs.w;
                let pitChance = Math.min(0.4, 0.2 + (level * 0.02));
                let isPit = (lastObs.type !== 'pit_marker') && Math.random() < pitChance;

                if (isPit) {
                    let gapSize = 100 + (level * 10) + Math.random() * 40; 
                    obstacles.push({ x: startX, y: 350, w: gapSize, h: 0, type: 'pit_marker' });
                } else {
                    let width = 300 + Math.random() * 300;
                    obstacles.push({ x: startX, y: 350, w: width, h: 50, type: 'floor' });
                    let wallChance = Math.min(0.6, 0.3 + (level * 0.05));
                    if (Math.random() < wallChance) {
                        let treeW = 40; let treeH = 80;
                        obstacles.push({ x: startX + 50 + Math.random() * (width - 150), y: 350 - treeH, w: treeW, h: treeH, type: 'tree' });
                    }
                }
            }
        }

        function spawnClouds() {
            if (clouds.length < 8 && Math.random() < 0.03) {
                clouds.push({ x: canvas.width + 50, y: Math.random() * 150, size: 20 + Math.random() * 30, speed: 0.5 + Math.random() * 1 });
            }
        }

        function update() {
            const vol = getVolumeLevel();
            volBar.style.width = vol + "%";
            let wantsToWalk = vol > CONFIG.walkThreshold;
            let wantsToJump = vol > CONFIG.jumpThreshold;

            if (player.grounded) {
                if (wantsToJump) {
                    player.vy = CONFIG.jumpForce;
                    player.grounded = false;
                    movingMomentum = wasWalking;
                    Assets.playJump(); 
                    statusEl.innerText = movingMomentum ? "JUMP FWD" : "JUMP UP";
                    statusEl.style.color = "#e74c3c";
                } else {
                    movingMomentum = wantsToWalk;
                    wasWalking = wantsToWalk;
                    statusEl.innerText = movingMomentum ? "WALKING" : "STOPPED";
                    statusEl.style.color = movingMomentum ? "#2ecc71" : "#bdc3c7";
                }
            } else {
                if (movingMomentum) { statusEl.innerText = "FLYING"; statusEl.style.color = "#e74c3c"; }
            }

            player.vy += CONFIG.gravity; player.y += player.vy;

            if (movingMomentum) {
                let currentSpeed = CONFIG.baseSpeed * speedMultiplier;
                distance += currentSpeed;
                scoreEl.innerText = Math.floor(distance / 10) + "m";
                for (let i = 0; i < obstacles.length; i++) obstacles[i].x -= currentSpeed;
                for (let i = 0; i < clouds.length; i++) clouds[i].x -= clouds[i].speed * (currentSpeed / 4);
                spawnTerrain(); spawnClouds();
            }

            for (let i = clouds.length - 1; i >= 0; i--) { if (clouds[i].x < -100) clouds.splice(i, 1); }

            player.grounded = false; 
            let pB = player.y + player.height/2; let pR = player.x + player.width/2; let pL = player.x - player.width/2;

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                if (ob.x + ob.w < -100) { obstacles.splice(i, 1); continue; }
                if (ob.type === 'pit_marker') continue;

                if (pR > ob.x && pL < ob.x + ob.w && pB > ob.y && player.y - player.height/2 < ob.y + ob.h) {
                    if (ob.type === 'tree') { gameOver(); return; } 
                    if (ob.type === 'floor') {
                        if (player.vy >= 0 && pB <= ob.y + 20) {
                            player.y = ob.y - player.height/2; player.vy = 0; player.grounded = true;
                        } else { gameOver(); return; }
                    }
                }
            }
            if (player.y > canvas.height + 50) gameOver();
        }

        function drawReindeer(x, y, grounded) {
            let startX = x - 15; let startY = y - 15;
            ctx.fillStyle = "#8B4513"; ctx.fillRect(startX + 5, startY + 10, 20, 12); 
            ctx.fillStyle = "#A0522D"; ctx.fillRect(startX + 20, startY + 5, 10, 10); 
            ctx.fillStyle = "#FF0000"; ctx.fillRect(startX + 28, startY + 8, 4, 4);
            ctx.fillStyle = "#5D4037"; 
            if (grounded) { ctx.fillRect(startX + 8, startY + 22, 4, 8); ctx.fillRect(startX + 20, startY + 22, 4, 8); } 
            else { ctx.fillRect(startX + 5, startY + 20, 4, 6); ctx.fillRect(startX + 22, startY + 24, 4, 6); }
            ctx.fillStyle = "#D2B48C";
            ctx.fillRect(startX + 21, startY, 2, 5); ctx.fillRect(startX + 19, startY-3, 2, 3);
            ctx.fillRect(startX + 26, startY, 2, 5); ctx.fillRect(startX + 28, startY-3, 2, 3);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(236, 240, 241, 0.8)";
            for (let c of clouds) { ctx.fillRect(c.x, c.y, c.size, c.size/2); ctx.fillRect(c.x+5, c.y-5, c.size-10, c.size/2+5); }
            
            for (let ob of obstacles) {
                if (ob.type === 'pit_marker') continue;
                if (ob.type === 'tree') {
                    // Safety check: is image really loaded?
                    if(Assets.images.tree.complete && Assets.images.tree.naturalHeight !== 0) {
                         ctx.drawImage(Assets.images.tree, ob.x, ob.y, ob.w, ob.h);
                    } else {
                        // Fallback: Draw green box if missing
                        ctx.fillStyle = 'green'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
                    }
                } else {
                    if(Assets.images.ground.complete && Assets.images.ground.naturalHeight !== 0) {
                        let pattern = ctx.createPattern(Assets.images.ground, 'repeat');
                        ctx.fillStyle = pattern;
                        ctx.save();
