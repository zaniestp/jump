<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Reindeer Mountain Adventure: House Edition</title>
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #638599; 
            font-family: 'Courier New', Courier, monospace;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; user-select: none; -webkit-user-select: none; touch-action: none;
        }
        canvas {
            border: 4px solid #2c3e50; background-color: #638599;
            box-shadow: 0px 5px 20px rgba(0,0,0,0.4);
            display: block; image-rendering: pixelated; 
            max-width: 100%; max-height: 100%; width: 800px; height: auto;
        }
        #ui-layer {
            position: absolute; top: 10px; left: 10px; right: 10px; pointer-events: none;
            background: rgba(44, 62, 80, 0.95);
            padding: 10px; border: 2px solid #1a252f; color: #ecf0f1;
            box-shadow: 3px 3px 0px rgba(0,0,0,0.6);
            display: flex; flex-direction: column; gap: 5px; max-width: 400px; margin: 0 auto;
            border-radius: 8px;
        }
        .top-row { display: flex; justify-content: space-between; align-items: center; }
        #score { font-size: 20px; font-weight: 900; color: #f1c40f; }
        #level-indicator { font-size: 12px; color: #e74c3c; font-weight: bold; text-transform: uppercase; }
        #status { font-size: 12px; font-weight: bold; color: #bdc3c7; text-align: right;}
        .meter-box { width: 100%; height: 15px; background: #34495e; border: 2px solid #1a252f; position: relative; overflow: hidden; border-radius: 4px; }
        .meter-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.05s ease-out; }
        .marker { position: absolute; top: 0; bottom: 0; width: 2px; background: #ecf0f1; z-index: 2; }
        #start-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #ecf0f1; padding: 25px; text-align: center;
            border: 4px solid #2c3e50; box-shadow: 5px 5px 0px #000;
            width: 85%; max-width: 400px; z-index: 100; border-radius: 10px;
        }
        button {
            background-color: #c0392b; color: white; border: 3px solid #000;
            padding: 15px; width: 100%; font-size: 18px; font-weight: 900;
            cursor: pointer; box-shadow: 3px 3px 0 #000; margin-top: 20px;
            font-family: 'Courier New', Courier, monospace; -webkit-appearance: none; border-radius: 5px;
        }
        button:active { box-shadow: 0 0 0 #000; transform: translateY(3px); }
        button:disabled { background-color: #7f8c8d; color: #bdc3c7; cursor: not-allowed; }
        .error-msg { color: #c0392b; font-weight: bold; background: #fadbd8; padding: 10px; border: 2px solid #c0392b; margin-top: 15px; display: none; font-size: 12px; text-align: left;}
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="top-row">
            <div id="score">0m</div>
            <div id="status">Waiting...</div>
        </div>
        <div id="level-indicator">Level 1</div>
        <div class="meter-box">
            <div id="vol-bar" class="meter-fill"></div>
            <div class="marker" style="left: 10%;"></div> 
            <div class="marker" style="left: 65%;"></div>
        </div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 24px; margin-bottom: 10px; margin-top:0;">Mountain Adventure</h1>
        <div style="background:#bdc3c7; padding:10px; border-radius:5px; font-size:13px; text-align:left; color:#2c3e50;">
            <p style="margin:5px 0;">üé§ <b>Microphone Required</b></p>
            <p style="margin:5px 0;">üó£Ô∏è <b>Talk</b> to Run Forward</p>
            <p style="margin:5px 0;">üì¢ <b>Shout</b> to Jump</p>
        </div>
        <button id="start-btn" onclick="startGame()">START GAME</button>
        <p id="error-log" class="error-msg"></p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const CONFIG = {
            walkThreshold: 10,   
            jumpThreshold: 65,   
            gravity: 0.5,
            jumpForce: -13,
            baseSpeed: 4
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level-indicator');
        const statusEl = document.getElementById('status');
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const errorLog = document.getElementById('error-log');
        const volBar = document.getElementById('vol-bar');

        canvas.width = 800;
        canvas.height = 400;
        ctx.imageSmoothingEnabled = false; 

        let audioContext, analyser, dataArray;
        let gameRunning = false;
        let distance = 4900;
        let speedMultiplier = 1;
        
        let player = { x: 150, y: 320, width: 30, height: 30, vy: 0, grounded: true };
        let movingMomentum = false; 
        let wasWalking = false;     
        let obstacles = [];
        let clouds = [];

        // --- ASSET LOADER ---
        const Assets = {
            images: {},
            sounds: {},
            loaded: 0,
            toLoad: 3, // Tree, Ground, House
            onReady: null,

            loadImages: function() {
                // 1. Tree
                this.images.tree = new Image();
                this.images.tree.onload = () => { console.log("Tree loaded"); this.assetLoaded(); };
                this.images.tree.onerror = () => { console.warn("Tree missing"); this.assetLoaded(); };
                this.images.tree.src = 'media/pine_tree.png'; 

                // 2. Ground
                this.images.ground = new Image();
                this.images.ground.onload = () => { console.log("Ground loaded"); this.assetLoaded(); };
                this.images.ground.onerror = () => { console.warn("Ground missing"); this.assetLoaded(); };
                this.images.ground.src = 'media/mountain_ground.png'; 

                // 3. House (NEW)
                this.images.house = new Image();
                this.images.house.onload = () => { console.log("House loaded"); this.assetLoaded(); };
                this.images.house.onerror = () => { console.warn("House missing"); this.assetLoaded(); };
                this.images.house.src = 'media/house.png'; 
            },

            loadSounds: function() {
                try {
                    this.sounds.jump = new Audio('media/jump.wav');
                    this.sounds.death = new Audio('media/death.wav');
                    this.sounds.music = new Audio('media/music.mp3');
                    this.sounds.music.loop = true;
                    this.sounds.music.volume = 0.3; 
                } catch(e) { console.warn("Sound init failed"); }
            },

            assetLoaded: function() {
                this.loaded++;
                if(this.loaded === this.toLoad && this.onReady) {
                    this.onReady();
                }
            },

            playJump: function() { if(this.sounds.jump) { this.sounds.jump.currentTime = 0; this.sounds.jump.play().catch(e=>{}); } },
            playDeath: function() { if(this.sounds.death) { this.sounds.death.play().catch(e=>{}); } }
        };

        // --- GAME START LOGIC ---
        async function startGame() {
            startBtn.disabled = true;
            errorLog.style.display = 'none';

            if (Assets.loaded >= Assets.toLoad) {
                startBtn.innerText = "Restarting...";
                await initializeAudio();
                return;
            }

            startBtn.innerText = "Loading Files...";

            Assets.onReady = async () => {
                startBtn.innerText = "Connecting Mic...";
                await initializeAudio();
            };

            Assets.loadImages();
            Assets.loadSounds();
        }

        async function initializeAudio() {
             if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { 
                showError("Browser not supported. Please use Chrome or Edge."); return; 
            }
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') await audioContext.resume();
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                startScreen.style.display = 'none';
                resetGame();
                gameRunning = true;
                
                if(Assets.sounds.music) {
                    Assets.sounds.music.play().catch(e => console.log("Auto-play blocked"));
                }
                
                requestAnimationFrame(gameLoop);

            } catch (err) {
                console.error(err);
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showError("Microphone Access Denied! Please refresh and click 'Allow'.");
                } else {
                    showError("Error: " + err.message);
                }
                startBtn.disabled = false;
                startBtn.innerText = "Try Again";
            }
        }

        function showError(msg) { errorLog.innerText = msg; errorLog.style.display = 'block'; }

        function getVolumeLevel() {
            if (!analyser) return 0;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            let avg = sum / dataArray.length;
            return Math.min(100, avg * 2.8); 
        }

        // --- GAMEPLAY LOGIC ---
        function resetGame() {
            player.y = 320; player.vy = 0; player.grounded = true;
            movingMomentum = false; wasWalking = false;
            distance = 4900; speedMultiplier = 1;
            scoreEl.innerText = "0m"; levelEl.innerText = "Level 1";
            obstacles = []; clouds = [];
            
            obstacles.push({ x: 0, y: 350, w: 800, h: 50, type: 'floor' });
            
            for(let i=0; i<6; i++) {
                clouds.push({ x: Math.random() * canvas.width, y: Math.random() * 150, size: 20 + Math.random() * 30, speed: 0.5 + Math.random() * 1 });
            }
        }

        function calculateDifficulty() {
            let level = 1 + Math.floor(distance / 1000);
            let targetSpeed = 1 + (level * 0.15); 
            speedMultiplier = Math.min(2.0, targetSpeed);
            levelEl.innerText = "Level " + level + (speedMultiplier >= 2.0 ? " (MAX)" : "");
            return level;
        }

        function spawnTerrain() {
            const lastObs = obstacles[obstacles.length - 1];
            if (lastObs && (lastObs.x + lastObs.w) < canvas.width + 100) {
                let level = calculateDifficulty();
                let startX = lastObs.x + lastObs.w;
                let pitChance = Math.min(0.4, 0.2 + (level * 0.02));
                let isPit = (lastObs.type !== 'pit_marker') && Math.random() < pitChance;

                if (isPit) {
                    let gapSize = 100 + (level * 10) + Math.random() * 40; 
                    obstacles.push({ x: startX, y: 350, w: gapSize, h: 0, type: 'pit_marker' });
                } else {
                    let width = 300 + Math.random() * 300;
                    obstacles.push({ x: startX, y: 350, w: width, h: 50, type: 'floor' });
                    
                    let wallChance = Math.min(0.6, 0.3 + (level * 0.05));
                    if (Math.random() < wallChance) {
                        
                        // --- HOUSE LOGIC START ---
                        let spawnHouse = false;
                        
                        // Condition: Distance > 300m
                        if (distance > 3000) { // 300m = 3000 distance units
                            let houseProb = 0.2; // 20% chance
                            if (distance > 4900) { // 490m = 4900 distance units
                                houseProb = 0.6; // 60% chance (More frequent)
                            }
                            if (Math.random() < houseProb) spawnHouse = true;
                        }
                        
                        if (spawnHouse) {
                            // Spawn House
                            let houseSize = 60; // Size of house
                            obstacles.push({ x: startX + 50 + Math.random() * (width - 150), y: 350 - houseSize, w: houseSize, h: houseSize, type: 'house' });
                        } else {
                            // Spawn Tree (Default)
                            let treeW = 40; let treeH = 80;
                            obstacles.push({ x: startX + 50 + Math.random() * (width - 150), y: 350 - treeH, w: treeW, h: treeH, type: 'tree' });
                        }
                        // --- HOUSE LOGIC END ---
                        
                    }
                }
            }
        }

        function spawnClouds() {
            if (clouds.length < 8 && Math.random() < 0.03) {
                clouds.push({ x: canvas.width + 50, y: Math.random() * 150, size: 20 + Math.random() * 30, speed: 0.5 + Math.random() * 1 });
            }
        }

        function update() {
            const vol = getVolumeLevel();
            volBar.style.width = vol + "%";
            let wantsToWalk = vol > CONFIG.walkThreshold;
            let wantsToJump = vol > CONFIG.jumpThreshold;

            if (player.grounded) {
                if (wantsToJump) {
                    player.vy = CONFIG.jumpForce;
                    player.grounded = false;
                    movingMomentum = wasWalking; 
                    Assets.playJump(); 
                    statusEl.innerText = movingMomentum ? "JUMP FWD" : "JUMP UP";
                    statusEl.style.color = "#e74c3c";
                } else {
                    movingMomentum = wantsToWalk;
                    wasWalking = wantsToWalk;
                    statusEl.innerText = movingMomentum ? "RUNNING" : "STOPPED";
                    statusEl.style.color = movingMomentum ? "#2ecc71" : "#bdc3c7";
                }
            } else {
                if (movingMomentum) { statusEl.innerText = "FLYING"; statusEl.style.color = "#e74c3c"; }
            }

            player.vy += CONFIG.gravity; 
            player.y += player.vy;

            if (movingMomentum) {
                let currentSpeed = CONFIG.baseSpeed * speedMultiplier;
                distance += currentSpeed;
                scoreEl.innerText = Math.floor(distance / 10) + "m";
                for (let i = 0; i < obstacles.length; i++) obstacles[i].x -= currentSpeed;
                for (let i = 0; i < clouds.length; i++) clouds[i].x -= clouds[i].speed * (currentSpeed / 4);
                spawnTerrain(); spawnClouds();
            }

            for (let i = clouds.length - 1; i >= 0; i--) { if (clouds[i].x < -100) clouds.splice(i, 1); }

            player.grounded = false; 
            let pB = player.y + player.height/2; 
            let pR = player.x + player.width/2; 
            let pL = player.x - player.width/2;

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                if (ob.x + ob.w < -100) { obstacles.splice(i, 1); continue; }
                if (ob.type === 'pit_marker') continue;

                if (pR > ob.x && pL < ob.x + ob.w && pB > ob.y && player.y - player.height/2 < ob.y + ob.h) {
                    
                    // Collision with Obstacles (Tree OR House)
                    if (ob.type === 'tree' || ob.type === 'house') { 
                        gameOver(); return; 
                    } 
                    
                    if (ob.type === 'floor') {
                        if (player.vy >= 0 && pB <= ob.y + 20) {
                            player.y = ob.y - player.height/2; player.vy = 0; player.grounded = true;
                        } else { gameOver(); return; }
                    }
                }
            }
            if (player.y > canvas.height + 50) gameOver();
        }

        // --- DRAWING ---
        function drawReindeer(x, y, grounded) {
            let startX = x - 15; let startY = y - 15;
            ctx.fillStyle = "#8B4513"; ctx.fillRect(startX + 5, startY + 10, 20, 12); 
            ctx.fillStyle = "#A0522D"; ctx.fillRect(startX + 20, startY + 5, 10, 10); 
            ctx.fillStyle = "#FF0000"; ctx.fillRect(startX + 28, startY + 8, 4, 4); 
            ctx.fillStyle = "#5D4037"; 
            if (grounded) { ctx.fillRect(startX + 8, startY + 22, 4, 8); ctx.fillRect(startX + 20, startY + 22, 4, 8); } 
            else { ctx.fillRect(startX + 5, startY + 20, 4, 6); ctx.fillRect(startX + 22, startY + 24, 4, 6); }
            ctx.fillStyle = "#D2B48C"; 
            ctx.fillRect(startX + 21, startY, 2, 5); ctx.fillRect(startX + 19, startY-3, 2, 3);
            ctx.fillRect(startX + 26, startY, 2, 5); ctx.fillRect(startX + 28, startY-3, 2, 3);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(236, 240, 241, 0.8)";
            for (let c of clouds) { ctx.fillRect(c.x, c.y, c.size, c.size/2); ctx.fillRect(c.x+5, c.y-5, c.size-10, c.size/2+5); }
            
            for (let ob of obstacles) {
                if (ob.type === 'pit_marker') continue;
                
                // DRAW HOUSE
                if (ob.type === 'house') {
                    if(Assets.images.house.complete && Assets.images.house.naturalWidth > 0) {
                         ctx.drawImage(Assets.images.house, ob.x, ob.y, ob.w, ob.h);
                    } else {
                        // Fallback Box (Purple)
                        ctx.fillStyle = '#9b59b6'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
                    }
                }
                
                // DRAW TREE
                else if (ob.type === 'tree') {
                    if(Assets.images.tree.complete && Assets.images.tree.naturalWidth > 0) {
                         ctx.drawImage(Assets.images.tree, ob.x, ob.y, ob.w, ob.h);
                    } else {
                        // Fallback Box (Green)
                        ctx.fillStyle = '#27ae60'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
                    }
                } 
                
                // DRAW GROUND
                else {
                    if(Assets.images.ground.complete && Assets.images.ground.naturalWidth > 0) {
                        let pattern = ctx.createPattern(Assets.images.ground, 'repeat');
                        ctx.fillStyle = pattern;
                        ctx.save(); ctx.translate(ob.x, ob.y); ctx.fillRect(0, 0, ob.w, ob.h); ctx.restore();
                    } else {
                        // Fallback Box (Brown)
                        ctx.fillStyle = '#5d4037'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
                    }
                }
            }
            drawReindeer(player.x, player.y, player.grounded);
        }

        function gameOver() {
            if(gameRunning) Assets.playDeath();
            if(Assets.sounds.music) Assets.sounds.music.pause();
            gameRunning = false;
            startScreen.style.display = 'block';
            startScreen.querySelector('h1').innerText = "GAME OVER";
            startBtn.innerText = "TRY AGAIN";
            startBtn.disabled = false;
        }

        function gameLoop() { if (gameRunning) { update(); draw(); requestAnimationFrame(gameLoop); } }
    </script>
</body>
</html>
